#!/usr/bin/perl

# svg2vl version 1.0, implementing VL level specification version 1
# Matt Sarnoff (msarnoff@andrew.cmu.edu)
# May 2, 2005
# Converts a level plan in SVG format to the .vl format readable by the game.
# Works with SVGs generated by Inkscape 0.40 (http://www.inkscape.org).
# Not tested on newer versions. Don't try to run an SVG generated by anything
# other than Inkscape through here.
#
# Released under the GNU General Public License. See LICENSE for more details.

use strict;
#use lib "/usr/home/frenzy/perl5";

use SVG::Parser qw(SAX=XML::LibXML::Parser::SAX Expat SAX);

####### Main code #######

my $LAYER = 1;
my @MATRIX_STACK = ();
my %OBJECT_TABLE = ();
my %DOOR_TYPES = ("slide1", 0, "slide2", 1, "swing1cw", 2, "swing1ccw", 3, "swing2cw", 4, "swing2ccw", 5, "split");
my %TRIG_TYPES = ("normal", 0, "every", 1, "once", 2, "add", 4);
my $objecttablefile = "object_table.txt";
my $NUM_WC = 0;

# Level information
my ($NAME, $AUTHOR, $BG, $SCALE, $PLAYER, $AUGMENTED, $GRIDSIZE, $LIGHT, @WALLS, @DOORS, @FLOORS, @CEILINGS, @SURFACES, @OBJECTS, @LIGHTS, @MASKS, @NODES);
my ($GRIDORIGIN, $CELLSWIDE, %COORD_CACHE, @GRID);
my $MIN_X =  1000000;
my $MAX_X = -1000000;
my $MIN_Y =  1000000;
my $MAX_Y = -1000000;


mydie("Usage: $0 svg_file [object_table_file]\n") unless @ARGV;

# Tack on an extension if none specified
$_ = $ARGV[0];
$ARGV[0] .= ".svg" if (!/\.svg$/i);

$objecttablefile = $ARGV[1] if (defined $ARGV[1]);

# Hack-o-matic! For some reason the XML parser always dies when trying to read an XML
# comment. So we quickly run the file through sed to remove any comments.
system("sed -e 's/<\!-- .* -->//' -i \"\" $ARGV[0] ");

print "svg2vl by Matt Sarnoff\nImplementing VL specification 1\n";

# Load object table.
print "Loading object table...";
load_object_table($objecttablefile);
print "Loading SVG file $ARGV[0]...";
my $svg = SVG::Parser->new()->parsefile($ARGV[0]);

# This should have one child--the <svg> tag
my ($svgRoot) = $svg->getChildren();

# Parse the layer <g> groups
my @svgChildren = $svgRoot->getChildren();

print "\nSVG data loaded. Parsing...\n";
foreach my $svgChild (@svgChildren) {
    $LAYER = 1;
    if ($svgChild->getElementName() eq "g") {
        $_ = $svgChild->getAttribute("id");
        if (/^floor/) {
            $LAYER = 0;
        } elsif (/^arch/) {
            $LAYER = 1;
        } elsif (/^surfaces/) {
            $LAYER = 2;
        } elsif (/^paths/) {
            $LAYER = 3;
        } elsif (/^objects/) {
            $LAYER = 4;
        } elsif (/^lights/) {
            $LAYER = 5;
        } elsif (/^masks/) {
            $LAYER = 6;
        }

        #print "\n  Working on layer $LAYER\n    ";
    }
    load_elements($svgChild);
}
#print "\n\n";

mydie("*** Holy crap! You forgot to add a player object! ***\n") unless $PLAYER;

print "Data loaded. Writing vl file...\n";
my $outfile = $ARGV[0];
$outfile =~ s/svg$/vl/;
open(OUTFILE, ">$outfile");
print_vl();
print "Success. Min:($MIN_X, $MIN_Y) Max: ($MAX_X, $MAX_Y)\nTotals:\n";
my ($fc, $wc, $dc, $cc, $sc, $nc, $oc, $lc, $mc);
$fc = @FLOORS; $wc = @WALLS; $dc = @DOORS; $cc = @CEILINGS;
$sc = @SURFACES; $nc = @NODES; $oc = @OBJECTS; $lc = @LIGHTS; $mc = @MASKS;
print "Floor\tWall\tDoor\tCeil\tSurf\tNode\tObj\tLight\tMask\n";
print "$fc\t$wc\t$dc\t$cc\t$sc\t$nc\t$oc\t$lc\t$mc\n\nEnd of line.\n\n";

####### Subroutines #######

sub load_object_table
{
    my $file = $_[0];
    if (!(-f $file)) {
        print ("\n*** Object table \"$file\" not found. ***\n*** svg2vl will not understand objecttype string identifiers. ***\n");
        return;
    }
  
    open(INFILE, $file) || mydie("Could not open $file\n");
    my $count = 0;
    my $partcount = 1;
    my ($line, $id);
    while (<INFILE>) {
        $line = $_;
        if (substr($line, 0, 1) ne "#") {
            ($id) = split(/[ \t\r\n]/, $line);
            if ($id ne "") {
                if (/^(part:)/) {
                    $OBJECT_TABLE{$id} = $partcount; $partcount++;
                } else {
                    $OBJECT_TABLE{$id} = $count; $count++;
                }
            }
        }
    }
    close(INFILE);
    print "done\n";
}

sub object_table_lookup
{
    my ($otype, $elid) = @_;
    $_ = $otype;
  
    return 0 if ($otype eq "");
    
    if (/^[^0-9]/) {
        my $num = $OBJECT_TABLE{$otype};
        mydie("*** $otype is not a recognized type for object $elid. Aborting. ***\n\n") if ($num eq "");
        return $num;
    } else {
        return $otype;
    }
}

sub cyes                        # returns true if the color value exists
{
    return ($_[0] && $_[0] ne "none");
}

sub cno                         # returns true if the color value does not exist
{
    return (!$_[0] || $_[0] eq "none");
}

sub to3                         # converts a float to 3 decimal places
{
    return sprintf("%0.3f", $_[0]);
}

sub ctx                         # transforms a value from SVG "pixels" to VL units
{
    return to3($_[0])*1.25;
}

sub cty                         # same as above, but flips the sign for a y coordinate
{
    return -to3($_[0])*1.25;
}

sub apply_matrix
{
    my ($x, $y, $matrix) = @_;
    my ($a, $b, $c, $d, $e, $f) = split(/ +,? *|, */, $matrix);
    my $newX = $a*$x + $c*$y + $e;
    my $newY = $b*$x + $d*$y + $f;
    return ($newX, $newY);
}

sub apply_matrices
{
    my ($coords) = @_;
    my @cdts = split(" ",$coords);
    my $newcoords = "";
    # Split coordinate list into ordered pairs
    for (my $i = 0; $cdts[$i]; $i+=2) {
        my $x = $cdts[$i]; my $y = $cdts[$i+1];
        foreach my $mat (@MATRIX_STACK) {
            ($x, $y) = apply_matrix($x, $y, $mat);
        }
        $newcoords .= to3($x) . " " . to3($y) . " ";
    }

    return $newcoords;
}

sub apply_matrices_to_light
{
    my ($cx, $cy, $r) = split(" ",$_[0]);
    my ($cxr, $cyr);
    my $newcoords = "";
  
    $cxr = $cx+$r; $cyr = $cy;
    foreach my $mat (@MATRIX_STACK) { 
        ($cx, $cy) = apply_matrix($cx, $cy, $mat);
        ($cxr, $cyr) = apply_matrix($cxr, $cyr, $mat);
    }
    $newcoords .= to3($cx) . " " . to3($cy) . " " . to3($cxr-$cx);
  
    return $newcoords;
}

sub get_matrix_from_transform
{
    my $trans = $_[0];
    $_ = $trans;
    if (/(matrix|translate|scale|rotate|skewX|skewY) *\(([^\(\)]+)\)/) {
        if ($1 eq "matrix") {
            return "$2";
        } elsif ($1 eq "rotate") {
            return cos($2).",".sin($2).",".-sin($2).",".cos($2).",0,0";
        } elsif ($1 eq "skewX") {
            return "1,0,".tan($2).",1,0,0";
        } elsif ($1 eq "skewY") {
            return "1,".tan($2).",0,1,0,0";
        } elsif ($1 eq "translate") {
            #my ($x, $y) = split(/( +,? *)|(, *)/, $2);
            my ($x, $y) = split(/ +,? *|, */, $2);
            $y = 0 if ($y eq "");
            return "1 0 0 1 $x $y";
        } elsif ($1 eq "scale") {
            my ($x, $y) = split(/ +,? *|, */, $2);
            $y = $x if ($y eq "");
            return "$x 0 0 $y 0 0";
        }
    
    }
}

sub print_matrix_stack
{
    foreach my $mat (@MATRIX_STACK) {
        print "$mat\n";
    }
}

# woot for recursion
sub load_elements
{
    my $element = $_[0];

    # Check to see if this is the vl element
    if ($element->getElementName() eq "vl") {
        # Parse the vl info
        print "  Found the vl element\n";
    
        my $name = $element->getAttribute("name");
        $NAME = ($name) ? $name : "(none)";

        my $author = $element->getAttribute("author");
        $AUTHOR = ($author) ? $author : "(none)";
    
        my $aug = $element->getAttribute("augmented");
        $AUGMENTED = ($aug) ? 1 : 0;
        
        my $bg = $element->getAttribute("bg");
        $BG = ($bg) ? hex_color_to_gl($bg) : "0.0 0.0 0.0";
    
        my $lightcolor = $element->getAttribute("lightcolor");
        $LIGHT .= ($lightcolor) ? hex_color_to_gl($lightcolor)." " : "1.0 1.0 1.0 ";
    
        my $lightint = $element->getAttribute("lightintensity");
        $LIGHT .= ($lightint ne "") ? to3($lightint)." " : "0.200 ";
    
        my $lightdir = $element->getAttribute("lightdirection");
        $LIGHT .= ($lightdir ne "") ? $lightdir : "90";
  
        my $gridsize = $element->getAttribute("gridsize");
        $GRIDSIZE .= ($gridsize ne "") ? $gridsize : "20";
    } else {
        my @children = $element->getChildren();
  
        # If this is a <g> element and it has a transformation,
        # push it onto the matrix stack
    
        if ($element->getAttribute("transform")) {
            #print "Applying element's transformation matrix: " . $element->getAttribute("transform") . "\n"; 
            push(@MATRIX_STACK, get_matrix_from_transform($element->getAttribute("transform")));
            #print_matrix_stack();      
        }
    
        #foreach my $m (@MATRIX_STACK)
        # {  print "$m "; }
  
        #print "\n";
  
        foreach my $child (@children) {
            parse_element($child);
            load_elements($child) if $child->hasChildren();
        }
    
        # pop the matrix
        if ($element->getAttribute("transform")) {
            pop(@MATRIX_STACK);
        }
    }
}

# get this object's specific attributes, included ones inherited
# from its ancestors.
sub get_specific_attributes
{
    my $element = $_[0];
    my %attrs = ();
    my @ancestors = ($element);
    push(@ancestors, $element->getAncestors());
    my @names = ("fill", "fill-opacity", "stroke", "stroke-opacity", "stroke-width", "style",
                "friction", "cd", "trigger", "trigtype", "h", "force", "health", "particles", "particleqty", "ricochet",
                "objecttype", "heading", "state", "fixed", "unlockwhen", "openwhen", "jamwhen", "wakewhen", "killwhen",
                "flipnormal", "lightspot", "lit", "door",
                "opens", "speed", "delay", "key", "fadespeed", "reobscure", "flags");
  
    # start at the layer object (a direct descendant of the svg object)
    for (my $i = -3; $ancestors[$i]; $i--) {
        foreach my $name (@names) {
            if ($name eq "style") {
                $attrs{$name} .= ";".$ancestors[$i]->getAttribute($name) if ($ancestors[$i]->getAttribute($name) ne "");
            } else {
                $attrs{$name} = $ancestors[$i]->getAttribute($name) if ($ancestors[$i]->getAttribute($name) ne "");
            }
        }
    }
  
    return %attrs;
}

sub get_trigger_type
{
  my $trigtype = $_[0];
  my $typenum = 0;
  my $trigmode = 0;
  
  my @tokens = split(/ +/, $trigtype);
  foreach my $token (@tokens)
  {
    if ($token eq "whenshot")
    { $typenum |= 32; }
    elsif ($token eq "sound1")
    { $typenum |= 8; }
    elsif ($token eq "sound2")
    { $typenum |= 16; }
    else
    { $trigmode = $TRIG_TYPES{$token}; }
  }
  
  $typenum |= $trigmode;

  return $typenum;
}

# parse an element to get its relevant information
sub parse_element
{
    my $element = $_[0];

    # Parse other elements
    if ($element->getElementName() eq "path" ||
        $element->getElementName() eq "rect") {
        if ($element->getAttribute("transform")) {
            #print "Applying element's transformation matrix: " . $element->getAttribute("transform") . "\n"; 
            push(@MATRIX_STACK, get_matrix_from_transform($element->getAttribute("transform")));
            #print_matrix_stack();
        }
  
        my ($FC, $FO, $SC, $SO, $ST, $TYPE, $SPECIFIC, $COORDS, $tr);

        # Get specific attributes for this object; analyze this element's ancestry
        # and determine things like inherited properties.
        my %specificAttributes = get_specific_attributes($element);
    
        # Get color information from attributes
        my ($afc, $afo, $asc, $aso, $ast);
        $afc = $specificAttributes{"fill"};
        $afo = $specificAttributes{"fill-opacity"};
        $asc = $specificAttributes{"stroke"};
        $aso = $specificAttributes{"stroke-opacity"};
        $ast = $specificAttributes{"stroke-width"};
    
        #my $transform = $element->getAttribute("transform");
    
        #if ($transform)
        #{ $tr = get_matrix_from_transform($transform); }

        # Also extract information from style attribute; this will preempt
        # information defined in the attributes.
        my ($sfc, $sfo, $ssc, $sso, $sst) = 
            get_colors_from_style($specificAttributes{"style"});

        $FC = ($sfc) ? $sfc : $afc;
        $FO = ($sfo) ? $sfo : $afo;
        $SC = ($ssc) ? $ssc : $asc;
        $SO = ($sso) ? $sso : $aso;
        $ST = ($sst) ? $sst : $ast;
    

        # Determine the element type    
        $TYPE = determine_element_type($FC, $SC, $element->getAttribute("id"));
      
        my ($a, $otype, $ohead, $cdflags, $isplayer, $flip);
        $otype = "";
        $SPECIFIC = "";
        $isplayer = 0;
        $flip = 0;
        if ($TYPE eq "F") {
            $a = $specificAttributes{"friction"}; $SPECIFIC .= ($a) ? "$a " : "0.3 ";
            $a = $specificAttributes{"lit"};   $SPECIFIC .= ($a eq "n") ? "0 " : "1 ";
      
            $cdflags = 1;
            $a = $specificAttributes{"cd"};
            if ($a) {
                $cdflags ^= 1 if ($a eq "n");
            }
            $SPECIFIC .= "$cdflags ";
      
            $a = $specificAttributes{"trigger"};  $SPECIFIC .= ($a) ? "$a " : "0 ";
            $a = $specificAttributes{"trigtype"};  $SPECIFIC .= ($a) ? get_trigger_type($a)." " : "0 ";
        } elsif (index($TYPE, "W") > -1) {
            if ($TYPE eq "W" && $specificAttributes{"door"} eq "y") {
                $SPECIFIC .= to3($ST)." ";
                $a = $specificAttributes{"opens"};     $SPECIFIC .= ($a) ? "$DOOR_TYPES{$a} " : "0 ";
                $a = $specificAttributes{"speed"};     $SPECIFIC .= ($a) ? "$a " : "2 ";
                $a = $specificAttributes{"delay"};     $SPECIFIC .= ($a) ? "$a " : "1 ";
                $a = $specificAttributes{"key"};       $SPECIFIC .= ($a) ? "$a " : "0 ";
                $a = $specificAttributes{"unlockwhen"}; $SPECIFIC .= ($a) ? "$a " : "0 ";
                $a = $specificAttributes{"openwhen"}; $SPECIFIC .= ($a) ? "$a " : "0 ";
                $a = $specificAttributes{"jamwhen"}; $SPECIFIC .= ($a) ? "$a " : "0 ";
                
                my $doorflags = 1 | 2;
                $a = $specificAttributes{"flags"};
                if ($a) {
                    $doorflags ^= 1 if (substr($a,0,1) eq "n");
                    $doorflags ^= 2 if (substr($a,1,1) eq "n");
                }    
                $SPECIFIC .= "$doorflags ";
                $TYPE = "D";
            }
            
            $a = $specificAttributes{"h"};   $SPECIFIC .= ($a) ? "$a " : "10 ";
            $a = $specificAttributes{"lit"};   $SPECIFIC .= ($a eq "n") ? "0 " : "1 ";
            $a = $specificAttributes{"force"};    $SPECIFIC .= ($a) ? "$a " : "0 ";
            $a = $specificAttributes{"health"};   $SPECIFIC .= ($a) ? "$a " : "0 ";
      
            $a = object_table_lookup($specificAttributes{"particles"});   $SPECIFIC .= ($a) ? "$a " : "0 ";
            $a = $specificAttributes{"particleqty"};   $SPECIFIC .= ($a) ? "$a " : "0 ";
            
            if ($specificAttributes{"flipnormal"} eq "y") {
                $flip = 1;
            }
      
            $cdflags = 1 | 2;
            $a = $specificAttributes{"cd"};
            if ($a) {
                $cdflags ^= 1 if (substr($a,0,1) eq "n");
                $cdflags ^= 2 if (substr($a,1,1) eq "n");
            }
            $a = $specificAttributes{"ricochet"};
            $cdflags ^= 4 if ($a eq "y");
            $SPECIFIC .= "$cdflags ";
      
            $a = $specificAttributes{"trigger"};  $SPECIFIC .= ($a) ? "$a " : "0 ";
            $a = $specificAttributes{"trigtype"};  $SPECIFIC .= ($a) ? get_trigger_type($a)." " : "0 ";


        } elsif (index($TYPE, "C") > -1) {
            $a = $specificAttributes{"h"};   $SPECIFIC .= ($a) ? "$a " : "10 ";
            $a = $specificAttributes{"lit"};   $SPECIFIC .= ($a eq "n") ? "0 " : "1 ";
        } elsif ($TYPE eq "S") {
            $a = $specificAttributes{"friction"}; $SPECIFIC .= ($a) ? "$a " : "0.3 ";
            $a = $specificAttributes{"health"};   $SPECIFIC .= ($a) ? "$a " : "0 ";
            $a = object_table_lookup($specificAttributes{"particles"});   $SPECIFIC .= ($a) ? "$a " : "0 ";
            $a = $specificAttributes{"particleqty"};   $SPECIFIC .= ($a) ? "$a " : "0 ";
            $a = $specificAttributes{"lit"};   $SPECIFIC .= ($a eq "n") ? "0 " : "1 ";
      
            $cdflags = 1;
            $a = $specificAttributes{"cd"};
            if ($a) {
                $cdflags ^= 1 if ($a eq "n");
            }
            $SPECIFIC .= "$cdflags ";
      
            $a = $specificAttributes{"trigger"};  $SPECIFIC .= ($a) ? "$a " : "0 ";
            $a = $specificAttributes{"trigtype"};  $SPECIFIC .= ($a) ? get_trigger_type($a)." " : "0 ";
        }
        elsif ($TYPE eq "N" && $element->getElementName() eq "rect")
        {
          $COORDS = coords_from_object($element);
          $COORDS = apply_matrices($COORDS);
        }
        elsif ($TYPE eq "O" && $element->getElementName() eq "rect")
        {
            $COORDS = coords_from_object($element);
            $COORDS = apply_matrices($COORDS);
            $otype = $specificAttributes{"objecttype"};
      
            mydie("*** No objecttype specified for object " . $element->getAttribute("id") . ". Aborting. ***\n\n") if ($otype eq "");
            $otype = object_table_lookup($otype, $element->getAttribute("id"));
      
            $ohead = $specificAttributes{"heading"};
            $ohead = ($ohead ne "") ? $ohead : 0;
            if ($otype eq "0") {
                $PLAYER = convert_coordinates($COORDS) . " $ohead";
                $isplayer = 1;
            } else {
                $SPECIFIC .= (($otype ne "") ? "$otype " : "1 ") . "$ohead ";
                $a = $specificAttributes{"state"};    $SPECIFIC .= ($a eq "idle") ? "0 " : "1 ";
                $a = $specificAttributes{"fixed"};   $SPECIFIC .= ($a eq "y") ? "1 " : "0 ";
                $a = $specificAttributes{"wakewhen"}; $SPECIFIC .= ($a ne "") ? "$a " : "0 ";
                $a = $specificAttributes{"killwhen"}; $SPECIFIC .= ($a ne "") ? "$a " : "0 ";
                $a = $specificAttributes{"trigger"};  $SPECIFIC .= ($a ne "") ? "$a " : "0 ";    
                $a = $specificAttributes{"trigtype"};  $SPECIFIC .= ($a) ? get_trigger_type($a)." " : "0 "; 
            }
        } elsif ($TYPE eq "L" && ($element->getElementName() == "path" && $element->getAttribute("sodipodi:cx"))) {
            $COORDS = coords_from_light($element);
            $COORDS = apply_matrices_to_light($COORDS);
            $a = $specificAttributes{"lightspot"}; $SPECIFIC .= ($a eq "n") ? "0 " : "1 ";
        } elsif ($TYPE eq "M") {
            $a = $specificAttributes{"h"};   $SPECIFIC .= ($a) ? "$a " : "10 ";
            $a = $specificAttributes{"fadespeed"};   $SPECIFIC .= ($a) ? "$a " : "3 ";
            $a = $specificAttributes{"lit"};   $SPECIFIC .= ($a eq "n") ? "0 " : "1 ";
            $a = $specificAttributes{"reobscure"};   $SPECIFIC .= ($a eq "y") ? "1 " : "0 ";     
            $a = $specificAttributes{"openwhen"}; $SPECIFIC .= ($a) ? "$a " : "0 ";
        }

        # Parse the coordinates
        if ($isplayer) {
            print "Added the player \n    ";
        } else {
            if ($TYPE ne "O" && $TYPE ne "L" && $TYPE ne "N") {
                $COORDS = ($element->getElementName() eq "rect") ? coords_from_rect($element) :
                    coords_from_path($element, $flip);
                $COORDS = apply_matrices($COORDS);
            }
      
            #print "$TYPE ";
            add_element($TYPE, $COORDS, hex_color_to_gl($FC, $FO), hex_color_to_gl($SC, $SO), $SPECIFIC, $flip)
                unless !$COORDS;
        }
    
        if ($element->getAttribute("transform")) {
            pop(@MATRIX_STACK);
        }
    }
}

# convert a #rrggbb color to a floating-point OpenGL color
sub hex_color_to_gl
{
    my ($color, $opacity) = @_;
    my $c;
    $_ = $color;
    if (/\#([\dA-Fa-f]{2})([\dA-Fa-f]{2})([\dA-Fa-f]{2})/) {
        $c = to3(hex($1)/255) . " " . 
            to3(hex($2)/255) . " " . 
                to3(hex($3)/255);
    } else {
        $c = "0.0 0.0 0.0";
    }

    $c .= " " . to3($opacity) if defined $opacity;
    return $c;
}

# retrieve color information from the "style" attribute
sub get_colors_from_style
{
    my $style = $_[0];
    return "" if !$style;

    my ($fc, $fo, $sc, $so, $st);
    my @props = split(";", $style);
    foreach my $prop (@props) {
        $_ = $prop;
        $fc = $1 if (/fill:([^:;]+)/);
        $fo = $1 if (/fill-opacity:([^:;]+)/);
        $sc = $1 if (/stroke:([^:;]+)/);
        $so = $1 if (/stroke-opacity:([^:;]+)/);
        $st = $1 if (/stroke-width:([^:;]+)/);
    }
    return ($fc, $fo, $sc, $so, $st);
}

# determine an element's type (wall, floor, ceiling, surface, object) based on its stroke/fill and layer
sub determine_element_type
{
    my ($fill, $stroke, $id) = @_;
    # check floors
    if ($LAYER == 0) {
        return "F" if (cyes($fill));
    } elsif ($LAYER == 1) {    
        return "" . ((cyes($stroke)) ? "W" : "") . ((cyes($fill)) ? "C" : "");
    } elsif ($LAYER == 2) {
        return "S" if (cyes($fill)); 
    } elsif ($LAYER == 3) {
        return "N";
    } elsif ($LAYER == 4) {
        return "O";
    } elsif ($LAYER == 5) {
        return "L";
    } elsif ($LAYER == 6) {
        return "M";
    }

    return "";
}

# extract vertices from a "rect" object
sub coords_from_rect
{
    my $element = $_[0];
    my ($points, $x, $y, $w, $h);
    $x = $element->getAttribute("x"),
        $y = $element->getAttribute("y"),
            $w = $element->getAttribute("width"),
                $h = $element->getAttribute("height");

    $points = "$x $y ".
        ($x+$w)." ".$y . " ".
            ($x+$w)." ".($y+$h)." ".
                $x   ." ".($y+$h)." ".
                    "$x $y";
    return $points;
}

# extract coordinates from an object
sub coords_from_object
{
    my $element = $_[0];
    my ($points, $x, $y, $w, $h);
    $x = $element->getAttribute("x"),
        $y = $element->getAttribute("y"),
            $w = $element->getAttribute("width"),
                $h = $element->getAttribute("height");

    return ($x+($w/2)) . " " . ($y+($h/2));
}

# extract coordinates from a light
sub coords_from_light
{
    my $element = $_[0];
    my ($cx, $cy, $r);
    $cx = $element->getAttribute("sodipodi:cx");
    $cy = $element->getAttribute("sodipodi:cy");
    $r = ($element->getAttribute("sodipodi:rx")+$element->getAttribute("sodipodi:ry"))/2;
  
    return "$cx $cy $r";
}

# extract vertices from a "path" object, ignoring Bezier curve control points
sub coords_from_path
{
    my $element = $_[0];
    my ($points, @d, $x, $y, $ignore);

    @d = split(/ *(M|L) */, $element->getAttribute("d"));
    foreach my $p (@d) {
        $_ = $p;
        if (/[Cc]/) {
            mydie("Alert! Object " . $element->getAttribute("id") . " has one or more curved segments!\n");
        }
        if (/([\d.]+)( *,? *)([\d.]+)/) {
            $points .= "$1 $3 "; #ctx($1)." ".cty($3)." ";
        }
    }
    return substr($points, 0, length($points));
}

# converts a set of coordinates from svg coordinates to vl coordinates
sub convert_coordinates
{
    my @cdts = split(" ",$_[0]);
    my $flip = $_[1];
    my $newcoords = "";
  
    # Split coordinate list into ordered pairs
    # Reverse the path if the user requested it
    if ($flip) {
        @cdts = reverse(@cdts);
        for (my $i = 0; $cdts[$i]; $i+=2) {
            $newcoords .= ctx($cdts[$i+1]) . " " . cty($cdts[$i]) . " "; update_extremes(ctx($cdts[$i+1]), cty($cdts[$i]));
        }
    } else {
        for (my $i = 0; $cdts[$i]; $i+=2) {
            $newcoords .= ctx($cdts[$i]) . " " . cty($cdts[$i+1]) . " "; update_extremes(ctx($cdts[$i]), cty($cdts[$i+1]));
        }
    }
  
    return $newcoords;
}

sub convert_light_coordinates
{
    my ($cx, $cy, $r) = split(" ", $_[0]);
  
    update_extremes(ctx($cx), cty($cy));
    update_extremes(ctx($cx) + ctx($r), cty($cy));
    update_extremes(ctx($cx), cty($cy) + ctx($r));
    update_extremes(ctx($cx) - ctx($r), cty($cy));
    update_extremes(ctx($cx), cty($cy) - ctx($r));
  
    return ctx($cx) . " " . cty($cy) . " " . ctx($r);
}

sub update_extremes
{
    my ($x, $y) = @_;
    $MIN_X = $x if ($x < $MIN_X);
    $MAX_X = $x if ($x > $MAX_X);
    $MIN_Y = $y if ($y < $MIN_Y);
    $MAX_Y = $y if ($y > $MAX_Y);
}

# adds an element to the arrays
sub add_element
{
    my ($type, $points, $fill, $stroke, $specific, $flip) = @_;

    if (index($type, "W") > -1) {
        push(@WALLS, "$stroke   $specific    " . convert_coordinates($points, $flip));
    }
  
    if (index($type, "D") > -1) {
        push(@DOORS, "$stroke   $specific    " . convert_coordinates($points, $flip));
    }
  
    if (index($type, "F") > -1) {
        push(@FLOORS, "$fill   $specific    " . convert_coordinates($points, 0));
    }
  
    if (index($type, "C") > -1) {
        my @ceil_fields = split(/ +/, $specific);
        push(@CEILINGS, "$fill    $ceil_fields[0] $ceil_fields[1]  " . convert_coordinates($points, 0));
    }
  
    if (index($type, "S") > -1) {
        push(@SURFACES, "$fill   $specific    " . convert_coordinates($points, 0));
    }

    if (index($type, "N") > -1) {
        push(@NODES, convert_coordinates($points, 0));
    }
    
    if (index($type, "O") > -1) {
        push(@OBJECTS, "$specific    " . convert_coordinates($points, 0));
    }
  
    if (index($type, "L") > -1) {
        push(@LIGHTS, "$fill   $specific    " . convert_light_coordinates($points));
    }
  
    if (index($type, "M") > -1) {
        push(@MASKS, "$fill   $specific    " . convert_coordinates($points, 0));
    }
  
}

# outputs the level file
sub print_vl
{
    $NAME = "(no name)" if (!$NAME);
    $BG = "0.000 0.000 0.000" if (!$BG);
    $PLAYER = "0.000 0.000" if (!$PLAYER);
  
    print OUTFILE "vl $NAME\nby $AUTHOR\nbg $BG\nplayer $PLAYER $AUGMENTED\ngrid $MIN_X $MIN_Y $MAX_X $MAX_Y $GRIDSIZE\nambient $LIGHT\n\n";

    foreach my $floor (@FLOORS) {
        print OUTFILE "floor $floor\n";
    }
    print OUTFILE "\n";

    foreach my $wall (@WALLS) {
        print OUTFILE "walls $wall\n";
    }
    print OUTFILE "\n";
  
    foreach my $door (@DOORS) {
        print OUTFILE "door $door\n";
    }
    print OUTFILE "\n";

    foreach my $wall (@CEILINGS) {
        print OUTFILE "ceil $wall\n";
    }
    print OUTFILE "\n";

    foreach my $surf (@SURFACES) {
        print OUTFILE "surf $surf\n";
    }
    print OUTFILE "\n";

    foreach my $node (@NODES) {
      print OUTFILE "node $node\n";
    }
    print OUTFILE "\n";
    
    foreach my $obj (@OBJECTS) {
        print OUTFILE "obj $obj\n";
    }
    print OUTFILE "\n";
  
    foreach my $light (@LIGHTS) {
        print OUTFILE "light $light\n";
    }
    print OUTFILE "\n";

    foreach my $mask (@MASKS) {
        print OUTFILE "mask $mask\n";
    }
    print OUTFILE "\n";
}

sub mydie
{
    print $_[0];
    exit;
}
